<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: parsers | A Singleton is Deallocated]]></title>
  <link href="http://lawrencelomax.github.io/blog/categories/parsers/atom.xml" rel="self"/>
  <link href="http://lawrencelomax.github.io/"/>
  <updated>2014-09-11T22:45:50+01:00</updated>
  <id>http://lawrencelomax.github.io/</id>
  <author>
    <name><![CDATA[Lawrence Lomax]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Parsers - Introduction]]></title>
    <link href="http://lawrencelomax.github.io/blog/2014/09/11/swift-parsers-introduction/"/>
    <updated>2014-09-11T22:30:00+01:00</updated>
    <id>http://lawrencelomax.github.io/blog/2014/09/11/swift-parsers-introduction</id>
    <content type="html"><![CDATA[<p>This the first in a series of four posts on Parsing code in Swift. This first post takes a look at what the development landscape for Cocoa, Swift, Objective-C &amp; Parsers.</p>

<h3>Introduction</h3>

<p>iOS Development has been a fun ride over the last few years. Frameworks are added and improved and generally speaking follow some common idioms. UIKit is well-trodden ground with significant changes as the level of interactivity and responsiveness of what a mobile experience is moves ever forward. When new API introduced or refined, compatibility issues occur, we fix them, we add delete some code that new API subsumes, we write some new features using the new API.</p>

<p>The Backend of an Application is still a bit of a frontier. With no <code>BackEndKit</code> to provide a unified interface of a Network Connections and the Persistent State of the Application, there are no &lsquo;rails&rsquo; to start on and how a Backend is built can vary enormously from Application-to-Application. A expanding world of Libraries has sprung up to simplify and consolidate the thinking of how back-end components intact in Objective-C. Much of the dynamism and flexibility of the Objective-C runtime as well as preprocessor macros is leveraged in order to kill repetitious code with metaprogramming. Now that a new Programming language has arrived and new <a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/index.html">OS features that all but a modular design </a> the time is now to look at best practice in iOS App Backends.</p>

<p>There is a lot of concern how Swift can (and can&rsquo;t be used) used with existing ways of getting-stuff-done in Objective-C. WWDC 2014 and the following months have had a ton to learn, so lets review a little of what we know about how working with Swift will effect iOS Development.</p>

<h3>Cocoa &amp; Swift</h3>

<p>Swift Interoperability with Cocoa is a mostly known quantity. Objective-C interoperability is deeply ingrained in the language, regardless of the philosophical departures that Swift makes from Objective-C. Cocoa will remain, repeated casting will be inconvenient, Strong Types with the Optional type contract will allow us to reason better about the state of the Application. Smaller components of the Application can be migrated to a Swift world in a piecemeal way without drastically changing the underlying architecture due to the extent of the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216">interoperability features</a>.</p>

<p>There&rsquo;s a lot of new language features, with a focus on moving up the levels of abstraction<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Having <a href="http://swifter.natecook.com/type/LazySequence/">Lazy Sequences as part of the Standard Library</a> and setter <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html">side-effects as part of the language</a> all show that things are getting a lot more modern.</p>

<p>The compiler is now doing a lot more with type inference can be used to increase code density without sacrificing readability or intent. Functions are types like any other value, people are rejoicing as the syntax of the language can be pared back by removing the need to worry about pointers.</p>

<h3>Headers &amp; Classes</h3>

<p>Having headers is fantastic from a documentation point of view, but the evils of duplication makes can make them unwieldy as well as informative. Swift leans on Header generation<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> and access control to automate the process of generating an Interface from the Implementation itself. Implementation details don&rsquo;t need to be leaked and API stubs don&rsquo;t need to be copy-pasted between <code>.h</code> and <code>.m</code></p>

<p>The implementation of both State and Behavior become considerably &lsquo;cheaper&rsquo; to write, re-write and update. Classes require a fraction of the number of characters and lines-of-code to achieve the same results in terms of defining Properties and Methods to their Objective-C brethren<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>. By making the time taken to write and re-write a Class significantly easier, a great deal of the resistance of decomposing Classes into smaller and more testable Units is removed. The Units become smaller and easier to test, revising code becomes easier as part of a virtuous circle.</p>

<h3>Metaprogramming &amp; Dynamism</h3>

<p>Chief among the concerns with Swift is how we will cope without the dynamism that Objective-C offers. The malleability of the runtime allows for the creation and injection of functions at runtime<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>. Property Mapping libraries and Model Descriptions inspect classes at runtime, defining the interaction of Classes at a much higher level of abstraction. Reducing boiler plate code isn&rsquo;t just about convenience at the current moment in time, it reduces the entropy of the codebase over time.</p>

<p>However, applying these methods will just not work in Swift. Pure Swift constructs are closed at compile time and cannot be tinkered with at runtime. There is no preprocessor available for code generation before it hits the compile. Safety is king, requiring the code to be totally unambiguous about the semantics of the code if there is insufficient information for the Compiler to reason with. There is no Reflection package or framework for performing the same kind of interactions with Classes at runtime, so this seems like a huge problem.</p>

<p>However there are other ways of constructing and building Applications, using Abstractions that seem far away from the Gang-of-Four, Object Oriented Programming and the more dynamic idioms of Objective-C. Functional Programming provides us with abstractions that help us to dispense with the repetition of Imperative programming but without sacrificing safety and predictability. These techniques can be employed without the need to read 42 tutorials about what a Monad is and isn&rsquo;t. Functional Programming has a few fundamental particles, once we learn how they can be applied, the mathematics behind them become a mainly academic exercise that can be ignored if we want to. I&rsquo;ll cover this in the third article in this series.</p>

<h3>Parser Requirements</h3>

<p>Let&rsquo;s take a look at the how we can go about one component within an Application in Swift, Parsing.</p>

<p>I&rsquo;m defining &lsquo;Parsing&rsquo; to be the process of extracting data from <a href="http://en.wikipedia.org/wiki/Comparison_of_data_serialization_formats">Data Serialization format</a> such as XML or JSON, to a native Model structure, valid and usable by the rest of the Application[^monadic-parser]. The Parser itself can have some or all of the following requirements:</p>

<ol>
<li>Check that a Value exists for a given Key at the current level, or navigate the Data to a deeper level.</li>
<li>Distinguish between a terminal value in the Data Serialization itself versus the value not existing at all. A <code>null</code> value in a JSON needs to be represented in a distinct way to a value not existing at all.</li>
<li>Coerced a value in the Serialization format into the type of the value that is expected in the Model.</li>
<li>Fail early if the the Serialization Format differs in any way from our expectations, without crashing.</li>
<li>If Parsing failure occurs, five valuable output to make it easier to isolate whether the Parsing code&rsquo;s assumptions about the structure of the data are wrong, or that the structure of the data itself is wrong, or both a wrong.</li>
<li>Provide defaults, or ways of deterministically deriving defaults for values that are known to be optional in the data structure.</li>
<li>The interface to the Serialization format&rsquo;s contents should provide a level of abstraction consistent with how it should be used.</li>
<li>Don&rsquo;t let any external state effect the Parsing unless absolutely necessary. Really, don&rsquo;t.</li>
<li>Seriously, don&rsquo;t even think about modifying external state. Being able to make a parser concurrent with the rest of the application makes everybody happy.</li>
<li>It should be easy to Parse serialized data from a variety of sources into the parser. The data may come bundled with the Application, from a HTTP request, or a fixture in a Unit Test.</li>
<li>Write Unit Tests for all of the boundary conditions, so we can be super-certain that our understanding of the serialization format holds true in the implementation.</li>
<li>If our Unit Tests don&rsquo;t cover all of the possible conditions in the structure of the format and a new condition is discovered, write a test for to ensure as much of the information about the structure of the data has been captured as possible.</li>
<li>Don&rsquo;t make the interface for pulling data out of the Serialization more expansive than necessary. If functionality is required that can be expressed in terms of more fundamental extraction functions, define it as a composition of the more fundamental functions.</li>
</ol>


<p>This is not an exhaustive list of requirements and it has already exhausted you and I. Admittedly, some of these requirements are true of Software Development generally, but it is always worth thinking about.</p>

<p>In Objective-C, Parsing can be a minefield of typing and branching. I don&rsquo;t think I&rsquo;d be going out on a limb to say that it is one of the most fragile parts of most codebases. Because of its fragility, if an Objective-C Application has any Unit Tests whatsoever, the Parsing components will have the best coverage. This is a big driving force behind Libraries such as the brilliant <a href="https://github.com/mantle/mantle">Mantle</a></p>

<p>Regardless of the awesomeness of an Objective-C library for parsing data, it won&rsquo;t ever be possible to inspect the expected type of the destination property in the Model at runtime and thereby avoid issues with Model Objects having values of the wrong type assigned<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>. Not only that but Objective-C doesn&rsquo;t fail-fast if an Object assigned an Object of a class differs from the expected class that the assignee Object expects<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>. This leads to explosions that occurs far away from the original erroneous assignment<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>.</p>

<p>However, it would appear that the situation is even worse for Swift. Without much in the way of metaprogramming or some runtime magic it looks like the process of parsing will be incredibly repetitive and laborious.</p>

<h3>XML</h3>

<p>XML is an interesting serialization format because it isn’t JSON. It&rsquo;s a format that we like to chuckle about and deride because of the complexity, but the reality is there are many APIs that Applications need to connect to that use XML. I think that many of the problems that we have with parsing XML comes from the fact that the abstractions we use to extract data from XML aren&rsquo;t that great. Handling all of the failure points in Parsing is a hard task and that&rsquo;s why we want to automate it with metaprogramming and make it bulletproof with Unit Tests.</p>

<p>XML is also format because there is a good amount of variety in the ways that we model an XML document and its content in API<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>. Typically JSON is just extracted into the native Array, Dictionary, String &amp; Numeric types of the targeted programming language. XML grew in popularity at a time when system resources like available memory were at much more of a premium than they are today. Constraints like this tend to drive innovation in a few directions, which make the process of parsing a little bit more interesting that pulling values out of a language-native Dictionary object.</p>

<p>If you aren&rsquo;t a crazy person like me you&rsquo;ll probably stick a Webservice in front of whatever else you need to consume and do all the complex data processing on a Server<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>, then spit everything out in a RESTful JSON service that normalizes any intricacies and madness in the original data. However the reality isn&rsquo;t always so ideal and its up to the Client Software to process data from a variety of Sources and Serialization Formats.</p>

<h3>Next Time&hellip;</h3>

<p>In the <a href="/blog/2014/09/11/swift-parsers-imperative/">next post</a>, I&rsquo;ll be a crazy person and create a simple XML interface in Swift, and extract data out of it in an Imperative style.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The inevitable is happening in iOS Land; Higher Levels of Abstraction as device performance increases, Frameworks and specialized languages for performance critical code. On iOS this is the availability of Accelerate and Metal. The amount of C &amp; C++ in iOS Development may diminish, but I don&rsquo;t see it going away within the next decade.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>This can be seen in any imported Frameworks, whether they are provided by the User, a 3rd Party, or Apple. Just CMD+Click on a third party Class in Xcode and it will take you to the Class or Method definition.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>This means we&rsquo;ll all write better method documentation right?<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>A lot of the malleability of the Objective-C runtime has allowed to be built on top of it in the first place!<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>It is possible to do this by attatching data about Classes of the properties of a Class, manually or automatically (this is part of the role of <a href="https://developer.apple.com/library/mac/documentation/Cocoa/reference/CoreDataFramework/Classes/nsManagedobjectModel_Class/Reference/Reference.html">NSManagedObjectModel</a>). However, this isn&rsquo;t the same thing as being able to know what the Class of an <code>@property</code> is from the Objective-C runtime.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>I think my Pro Strong-Typing-bias is showing. I&rsquo;m just describing one of the disadvantages of a weak type system, when there are also benefits.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>The contracts of assignment can be a good deal stronger with liberal use of assertions like <code>NSParameterAssert</code>.<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>This is covered in more detail in the <a href="">fourth in this series</a>.<a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p>You&rsquo;ll also have your pick of languages on the server, so you can use a language &amp; framework that works well in this domain. Either way the Client App will have to consume data at some point and the App should be fault-tolerant enough that it doesn&rsquo;t fall over if there&rsquo;s a hiccup on the server.<a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Parsers - Imperative]]></title>
    <link href="http://lawrencelomax.github.io/blog/2014/09/11/swift-parsers-imperative/"/>
    <updated>2014-09-11T22:30:00+01:00</updated>
    <id>http://lawrencelomax.github.io/blog/2014/09/11/swift-parsers-imperative</id>
    <content type="html"><![CDATA[<p>In the <a href="/blog/2014/09/11/swift-parsers-introduction/">previous post</a> I talked about some of the possible requirements for a Parser that extracts data from a Serialization Format and places it in a Language-Native Model. In this post I&rsquo;ll cover how an XML Parser for a Model Object can be built using some of the familiar Imperative features of Swift.</p>

<h3>Model and XML</h3>

<p>Let&rsquo;s define a hypothetical XML that we wish to parse:</p>

<pre><code>&lt;zoo&gt;
    &lt;animals&gt;
        &lt;animal&gt;
            &lt;type&gt;cat&lt;/type&gt;
            &lt;name&gt;grumpy&lt;/name&gt;
            &lt;url&gt;http://en.wikipedia.org/wiki/Grumpy_Cat&lt;/url&gt;
        &lt;/animal&gt;
        &lt;animal&gt;
            &lt;type&gt;cat&lt;/type&gt;
            &lt;name&gt;long&lt;/name&gt;
            &lt;url&gt;http://knowyourmeme.com/memes/longcat&lt;/url&gt;
        &lt;/animal&gt;
        &lt;animal&gt;
            &lt;type&gt;dog&lt;/type&gt;
            &lt;name&gt;i have no idea what i'm doing&lt;/name&gt;
            &lt;url&gt;http://knowyourmeme.com/memes/i-have-no-idea-what-im-doing&lt;/url&gt;
        &lt;/animal&gt;
    &lt;/animal&gt;
    &lt;facilities&gt;
        &lt;toilet&gt;42&lt;/toilet&gt;
        &lt;disabled_parking&gt;true&lt;/disabled_parking&gt;
        &lt;a_random_assortment_of_characters&gt;sdfdf821n9sfa&lt;/a_random_assortment_of_characters&gt;
        &lt;seriously&gt;
            &lt;crazy_nested&gt;
                &lt;drainage&gt;Good&lt;/drainage&gt;
            &lt;/crazy_nested&gt;
        &lt;/seriously&gt;
    &lt;/facilities&gt;
&lt;/zoo&gt;
</code></pre>

<p>The Model includes the parts of the XML that our Application cares about and ignores others:</p>

<pre><code>public struct Animal {
  let type: String
  let name: String
  let url: NSURL
}

public struct Zoo {
  let toiletCount: Int
  let disabledParking: Bool
  let drainage: String
  let animals: [Animal]
 }
</code></pre>

<p>This is simple and immutable, the Parser forms part of the backend for the User Interface to consume. There&rsquo;s no reason for the User Interface to be able to manipulate these Models directly.</p>

<h3>An Interface to XML</h3>

<p>Stubbing a Protocol or Interface is a great way of getting to grips with the problem that needs to be solved. It also helps to determine what is necessary for to implement, as well as the details that can be ignored to solve the problem at hand. There is also a bunch of <a href="">previously laid out requirements to be considered</a></p>

<p>In parsing this XML<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. I&rsquo;ve made a few assumptions:</p>

<ol>
<li>I care about the data contained in Text Nodes.</li>
<li>I need to be able to recursively address Elements within a Tree-like structure.</li>
<li>I need to be able to enumerate Elements of the same name at the same level in the tree.</li>
<li>I don&rsquo;t care about anything else (namespaces, attributes, schemas).</li>
</ol>


<p>With those assumptions in mind, a Protocol for defining how data can be extracted from a Parsable XML Node can be made:</p>

<pre><code>public protocol XMLParsableType {
  func parseChildren(childTag: String) -&gt; [Self]
  func parseText() -&gt; String?
}
</code></pre>

<p><em>&ldquo;That&rsquo;s It?&rdquo;</em>. Yep. Everything else can be composed on top of this minimal protocol; more complex data extraction functions can be built on top of these fundamentals. It&rsquo;s easy to define the responsibility of this Protocol in one sentence:</p>

<blockquote><p><em>&ldquo;An XML Parsable has an ordered collection of Child Parsables and may have an associated String of Text&rdquo;</em></p></blockquote>

<p>Protocols are permitted to have a recursive definition, using the <code>Self</code> placeholder type. How and where the underlying XML document is stored is left to the implementing class/struct/enum<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. As we will see in <a href="">Part 4</a>, obtaining a child may be implemented by traversing a fully reified data structure, or moving a cursor partially visible representation of the structure.</p>

<p>As well as a representation of the Data Serialization itself, there needs to be a consistent way of defining that a Model can extract out values of Data Serialization. The entry point can be defined in terms of a decode protocol<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> that the Model structures should implement:</p>

<pre><code>public protocol XMLDecoderType {
  class func decode&lt;X: XMLParsableType&gt;(xml: X) -&gt; Result&lt;Self&gt;
}
</code></pre>

<p>This function will be where the action is and can be implemented in the Model type definitions themselves or separately as Extensions. As <code>XMLParsableType</code> has a <code>Self</code> requirement, the usage of an <code>XMLParsableType</code> protocol needs to be <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-XID_286">satisfied with Generics</a>.</p>

<h3>Surfacing Failure</h3>

<p>In the interface for <code>XMLParsableType</code>, failure is indicated with the return of <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_483">the <code>None</code> case of the <code>Optional</code> enum</a>. An <code>Optional</code> surrounds the value with a <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Context describing the availability of the value</a>. The absence of a value in a <code>XMLParsableType</code> indicates some kind of failure, but without any information about how the Error came about.</p>

<p>Some Cocoa APIs use <code>nil</code> as the return value represent failure<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> alone, but idiomatic Cocoa will also include a by-reference <code>NSError</code> to return Error Information in the event of failure. Exceptions are being <a href="https://twitter.com/atnan/status/506832064633901056">weeded out of Cocoa API</a> for all but programmer error. <code>NSError</code> has the an associated <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/Reference/Reference.html#//apple_ref/occ/instm/NSError/domain">&ldquo;Error Domain&rdquo;</a> as well as <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/Reference/Reference.html#//apple_ref/doc/uid/20001704-CJBIAHGF"><code>String</code> Description</a> of the cause of the failure. This can be massively helpful as finding the code or resource that is responsible is a nightmare if the only information is &ldquo;a problem occurred somewhere&rdquo;. For example the <code>NSJSONSerialization</code> API will give the line-number of a syntax error in a JSON resource.</p>

<p>Moving to a Safe Swift world, return of an <code>NSError</code> and a possible value can be encapsulated in the same value using an <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-XID_227">Enumeration with Associated Values</a>, rather <a href="https://www.google.co.uk/search?client=safari&amp;rls=en&amp;q=nserror+dereference+pointer&amp;ie=UTF-8&amp;oe=UTF-8&amp;gfe_rd=cr&amp;ei=3MEOVNesH4G28AOjw4D4Bw#rls=en&amp;q=nserror+dereference+pointer">dereferencing pointers</a>. This is the <code>Result</code> with the same availability semantics as an <code>Optional</code>, with additional failure information provided with an <code>NSError</code> in the failure case:</p>

<pre><code>public enum Result&lt;V&gt; {
  case Error(NSError)
  case Value(Box&lt;V&gt;)
}
</code></pre>

<p>As there are potentially many sources of failure in the <code>decode</code> method, it is handy to write a Helper Method that can &ldquo;promote&rdquo; an <code>Optional</code> to a <code>Result</code> with an Error if the Optional does not contain a value. This will populate the <code>NSError</code> with a default Error Domain and attach a User Defined message:</p>

<pre><code>public func promoteDecodeError&lt;V&gt;(message: String)(value: V?) -&gt; Result&lt;V&gt;
</code></pre>

<h3>An Imperative Approach</h3>

<p>From the previous post, I mentioned that the lack a dynamic runtime in Swift will mean that bringing over some Objective-C programming techniques will be impossible. As a Swift Parser won&rsquo;t be able to use these techniques, a more traditional approach to parsing will have to be used<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<p>Failing-Fast was outlined as a potential feature of a Parser in the previous post, the implementation of an XML-to-Animal decoding function will need to take this into account. The following Imperative approach shows how it may be possible to extract a <code>Result&lt;Animal&gt;</code> from an <code>XMLParsableType</code>:</p>

<pre><code>  static func decode&lt;X: XMLParsableType&gt;(xml: X) -&gt; Result&lt;Animal&gt; {
    if let type = XMLParser.parseChildText("type")(xml: xml).toOptional() {
      if let name = XMLParser.parseChildText("name")(xml: xml).toOptional() {
        if let urlString = XMLParser.parseChildText("url")(xml: xml).toOptional() {
          return Result.value(self(type: type, name: name, url: NSURL.URLWithString(urlString)) )
        }
        return Result.Error(decodeError("Could not parse 'urlString' as a String"))
      }
      return Result.Error(decodeError("Could not parse 'name' as a String"))
    }
    return Result.Error(decodeError("Could not parse 'type' as a String"))
  }
</code></pre>

<p>This doesn&rsquo;t look great. The nesting is terrible, the Failure and Success conditions are separated around the conditional. In this case, there are only three values, a Model with more properties would make the nesting significantly worse. In Objective-C this can be better tackled by returning early on failure, however this would require lots of force unwrapping<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>. Conditional Statements are required as Failure when one of the values is missing is a requirement of our Model and is guaranteed to exist in the XML.</p>

<p>Despite these problems, there are some patterns are emerging. Firstly, it looks like extracting the Text from a Child is a common enough task that can be converted to a function in its own right. Obtaining a Child&rsquo;s Child&rsquo;s looks like an interesting area for some more meaningful functions. Optional Chaining is being used to avoid further conditionals.</p>

<p>Most importantly is that the nesting is an Imperative way of implementing that the successful condition for this function is dependent on the availability of three values in the XML. Moving our understanding of the pattern from an Imperative model to a Declarative model will be crucial to building a better way of constructing a <code>decode</code> function.</p>

<h3>Next Time&hellip;</h3>

<p><a href="/blog/2014/09/11/swift-parsers-functional/">Next time</a>, we&rsquo;ll take a Functional approach to the <code>decode</code> method, allowing us to think at a much higher level about how a Model is built.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>These assumptions actually hold true for a <a href="http://www.livedepartureboards.co.uk/ldbws/">webservice to be consumed</a> in an Application I was prototyping. Depending on the Webservice an Application is consuming, there&rsquo;s a great deal of assumptions that can be made to reduce the complexity of an Implementation.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>One of the most interesting aspects of Haskell is <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">Lazy Evaluation</a>, in particular how it applies to building up a <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">data structure and then traversing it</a>.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>This is heavily inspired by the <a href="http://robots.thoughtbot.com/efficient-json-in-swift-with-functional-concepts-and-generics">ThoughtBot article on JSON Parsing in Swift</a>. In my Project I have multiple decoder types for JSON, XML and CSV.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>It is really important to understand the semantic differences between <code>nil</code> in Objective-C and <code>None</code>/<code>nil</code> in Objective-C. With Swift/Objective-C interoperability they are used interchangeably. In Swift they can be thought of as &ldquo;the absence of a value&rdquo;, but in Objective-C they can be both &ldquo;the absence of a value&rdquo; and a <a href="http://en.wikipedia.org/wiki/Null-terminated_string">terminal</a>. Swift features <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-XID_356">Optional Chaining</a> to replicate the nil-messaging of Objective-C. As Objective-C APIs cannot make guarantees about the availability of a Reference Type all of the Objective-C bridged APIs, <a href="ceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_30">Reference Types are exposed as Optionals &amp; Force-Unwrapped Optionals</a>.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>I certainly remember writing this kind of thing by hand, before <a href="http://docs.oracle.com/javase/tutorial/jaxb/intro/">Java annotations could be used for Code Generation</a>.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>It would look <a href="https://gist.github.com/lawrencelomax/00ea2c00c9b6ca5bb4ab">something like this</a><a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Parsers - Functional]]></title>
    <link href="http://lawrencelomax.github.io/blog/2014/09/11/swift-parsers-functional/"/>
    <updated>2014-09-11T22:30:00+01:00</updated>
    <id>http://lawrencelomax.github.io/blog/2014/09/11/swift-parsers-functional</id>
    <content type="html"><![CDATA[<p>In the <a href="/blog/2014/09/11/swift-parsers-imperative/">previous post</a> we built a <code>decode</code> function to parse data out from XML and into an <code>Animal</code> Model using Imperative techniques. This required some efforts in order to satisfy some of the robustness requirements from the <a href="/blog/2014/09/11/swift-parsers-introduction/">first post</a>.</p>

<p>In this post we&rsquo;ll cover how we can use Functional Programming techniques on top of the language features of Swift to decode XML to an <code>Animal</code> model. This post assumes that you are comfortable with the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-XID_278">Parameterized Types and Generics</a>.</p>

<h3>Thinking Functionally</h3>

<p>I&rsquo;m using the fantastic and lightweight <a href="https://github.com/maxpow4h/swiftz/">Swiftz</a> for go-to implementations<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> of many <a href="http://en.wikipedia.org/wiki/Higher-order_function">Higher-Order Functions</a>. It also has a great implementation of the <a href=""><code>Result</code> type from the previous post</a>.</p>

<p>One important concept in Functional Programming is that functions can be thought of as <a href="http://en.wikipedia.org/wiki/First-class_function">First-Class types</a> just like any other variable or constant in code. Objective-C has had blocks for some time now, allowing us to think in terms of passing functions around; assigning a block to a property of a Object. However this isn&rsquo;t the same thing as First-Class functions. Swift allows Functions to be First-Class whilst providing equivalence in functions no matter how they are declared, a <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html">Closure in Swift</a> is just another kind of function <a href="http://oleb.net/blog/2014/07/swift-instance-methods-curried-functions/">just like a method</a> or <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-XID_243">Free Function</a>. Blocks are no longer the best way of passing around a computation, we can consider the equivalence of functions declared with <code>func</code> in a Global or Class scope with local Closures:</p>

<pre><code>let intToNumber:  Int -&gt; NSNumber = NSNumber.numberWithInt
let intToNumber1: Int -&gt; NSNumber = { NSNumber.numberWithInt($0) }
</code></pre>

<p>By now it should be second nature to think of the concatenation of two Strings using the <a href="http://swifter.natecook.com/operator/pls/">+ operator</a>. As functions are types like any other, two functions can be joined together just like a String.</p>

<pre><code>public func •&lt;A, B, C&gt;(f: B -&gt; C, g: A -&gt; B) -&gt; A -&gt; C    // The 'compose' operator from Swiftz

func prefixer(prefix: String)(string: String) -&gt; String { // Equivalent to String -&gt; String -&gt; String
  return prefix + string
}
func postfixer(postfix: String)(bar: String) -&gt; String { // Equivalent to String -&gt; String -&gt; String
  return string + postfix
}

let happyPrefix = prefixer("😃") // String -&gt; String. The first String argument of 'prefixer' is applied.
let sadPostfix = postfixer("😞") // String -&gt; String. The first String argument of 'postfixer' is applied.
let infixer = happyPrefix • sadPostfix // String -&gt; String. Two functions are joined, the output of the first becomes the input of the second.
let string = infixer("Good Morning") // "😃 Good Morning 😞"
</code></pre>

<p>In this example, the Swiftz <a href="https://github.com/maxpow4h/swiftz/blob/master/swiftz_core/swiftz_core/Functions.swift#L59">compose operator (•)</a> is used in conjunction with <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html">Curried Functions</a>. This might look a little crazy for now, but two important concepts are:</p>

<ol>
<li>A specialized function can be created from a curried function, by applying some, but not all of the arguments.</li>
<li>New functions can be created locally by composing other functions with fancy operators.</li>
</ol>


<h3>Building new Parsers</h3>

<p>With the idea of composing functions <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-XID_598">without having to declare one</a> can be carried over to our problem of decoding XML to a Model;  A specialized Parser function can be made for each of the values that need to be parsed out in the Model. In order to construct an <a href=""><code>Animal</code> Model</a> three parsers are required, with the values placed into the context of a <code>Result</code> for failure information:</p>

<pre><code>let kindParser: XMLParsableType -&gt; Result&lt;String&gt; = ...
let nameParser: XMLParsableType -&gt; Result&lt;String&gt; = ...
let urlParser: XMLParsableType -&gt; Result&lt;String&gt; = ...
</code></pre>

<p>Further, we can think of each of the properties of a decoded <code>Animal</code> as the application of the above functions to the source <code>XMLParsableType</code> from the XML Document.</p>

<pre><code>let kind: Result&lt;String&gt; = typeParser(xml)
let name: Result&lt;String&gt; = typeParser(xml)
let url: Result&lt;String&gt; urlParser(xml)
</code></pre>

<p>We&rsquo;ve allready seen that we can use Swift&rsquo;s Optional Chaining in our parser to limit the number of occurences of handling failure. However, <code>Result</code> isn&rsquo;t a blessed by the language with <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-XID_356">special syntax for chaining</a>. It would be great to get the same behaviour for the Result type.</p>

<p>Turns out that Swiftz has the <a href="https://github.com/maxpow4h/swiftz/blob/master/swiftz_core/swiftz_core/Optional.swift#L42">following function declared</a><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>:</p>

<pre><code>public func &gt;&gt;-&lt;A, B&gt;(a: Result&lt;A&gt;, f: A -&gt; Result&lt;B&gt;) -&gt; Result&lt;B&gt;
</code></pre>

<p>It is called <a href="http://bit.ly/1weNYBM">&lsquo;Bind&rsquo;</a> and it can be described in the following way:</p>

<blockquote><p><em>&ldquo;If the parameter <em>a</em> is a Value case of the result apply the function <em>f</em> returning the <em>Result</em> of <em>f</em>. If the parameter <em>a</em> is an Error, just return the original <em>Result</em>&rdquo;</em></p></blockquote>

<p>Sounds the same as Optional Chaining! In fact Optional Chaining <a href="https://github.com/maxpow4h/swiftz/blob/master/swiftz_core/swiftz_core/Optional.swift#L42">can be defined in this way</a>. It should be possible to construct a <code>Result&lt;String&gt;</code> for the  <code>kind</code> value of an <code>Animal</code> this way:</p>

<pre><code>let kind: Result&lt;String&gt; = xml.parseChildren("type").first &gt;&gt;- { $0.parseText() } // Compiler Error!
</code></pre>

<p>Damn, looks like the types don&rsquo;t match up since the <code>kind</code> value should be a <code>Result&lt;String&gt;</code> instead of a <code>String?</code>. Besides, this looks much worse with needing to use an inline closure to invert the <code>parseText</code> 0-arg instance method on <code>xml</code> into a function that takes an <code>xml</code> parameter and executes <code>parseText</code>. There has to be a better way of doing this&hellip;</p>

<h3>XMLParser: A Helper</h3>

<p>A new approach is to create a few Helper Functions that build on top of the basic functionality of <code>XMLParsableType</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> to extract a Single child of a given Element name, providing the value in the context of a <code>Result</code> type, and accept the <code>XMLParsableType</code> as a parameter of function that isn&rsquo;t bound to an instance:</p>

<pre><code>public final class XMLParser {
    public class func parseChild&lt;X: XMLParsableType&gt;(elementName: String)(xml: X) -&gt; Result&lt;X&gt; 
    public class func parseText&lt;X: XMLParsableType&gt;(xml: X) -&gt; Result&lt;String&gt;
}
</code></pre>

<p>This can then be used to extract out the <code>kind</code> value with our understanding of the <code>Bind</code><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> operator:</p>

<pre><code>let kind: Result&lt;String&gt; = XMLParser.parseChild("kind")(xml: xml) &gt;&gt;- XMLParser.parseText
</code></pre>

<p>Now we&rsquo;re talking! The <code>XMLParser.parseText</code> function is not invoked directly and is placed into a chain of operations to extract out text of an XML Element. These functions are being joined as if it were any other type of data.</p>

<p>The  <code>name</code> property of the <code>Animal</code> model is nested a few XML Elements deep, but it can be extracted by chaining the Parsing functions in the same way:</p>

<pre><code>let name: Result&lt;String&gt; = XMLParser.parseChild("nested_nonsense")(xml: xml) &gt;&gt;- XMLParser.parseChild("name") &gt;&gt;- XMLParser.parseText 
</code></pre>

<p>The <code>XMLParser.parseChild("name")</code> expression evaluates to a function of <code>XMLParsableType -&gt; Result&lt;XMLParsableType&gt;</code> instead of just a <code>Result</code> value. We&rsquo;re seeing that currying is being used to create a specialized Parser function for a specific XML element, chained together in a sequence of functions.</p>

<p>This is the heart of Function Composition, with <code>Bind</code> performing the behaviour of continuing on success, bailing out as soon as an Error occurs. The possibility of failure within any of the sequences of operations is an essential property of this Parser. Previously this was handled by Optional Chaining and <code>if</code> statements in the <a href="">Imperative version</a>. Using <code>&gt;&gt;-</code> there isn&rsquo;t a branching statement in sight<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<h3>Common Operations</h3>

<p>There appeares to be some common chained functions appearing. These can be extracted out and into the <code>XMLParser</code> class<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> and built using the same Higher-Order Functions and other functions and methods that have been defined for <code>XMLParserType</code></p>

<pre><code>extension XMLParser {
    public class func parseChildText&lt;X: XMLParsableType&gt;(elementName: String)(xml: X) -&gt; Result&lt;String&gt; {
      let textParser: X -&gt; Result&lt;String&gt; = promoteXmlError("Could not parse text for child \(elementName)") • { $0.parseText()}
      return self.parseChild(elementName)(xml: xml) &gt;&gt;- textParser
    }

    public class func parseChildRecursive&lt;X: XMLParsableType&gt;(elementNames: [String])(xml: X) -&gt; Result&lt;X&gt; {
      return elementNames.reduce(Result.value(xml)) { (parsable: Result&lt;X&gt;, currentElementName) in
        return parsable &gt;&gt;- self.parseChild(currentElementName)
      }
    }

    public class func parseChildRecusiveText&lt;X: XMLParsableType&gt;(elementNames: [String])(xml: X) -&gt; Result&lt;String&gt; {
      let textParser: X -&gt; Result&lt;String&gt; = promoteXmlError("Could not parse text for child \(elementNames.last)") • { $0.parseText()}
      return self.parseChildRecursive(elementNames)(xml: xml) &gt;&gt;- textParser
    }
}
</code></pre>

<p><a href="http://swifter.natecook.com/func/reduce/"><code>reduce</code></a> is another Higher-Order function of the <a href="http://swifter.natecook.com/protocol/SequenceType/"><code>Sequence</code> type</a> making an appearance. Using it means that the <code>parseChildRecursive</code> <a href="http://bit.ly/1qZxDCb">doesn&rsquo;t need to be implemented in a recursive manner</a>.</p>

<p>These functions can now be used with in the Animal <code>decode</code> function to make extracting data from the XML more obvious:</p>

<pre><code>let kind: Result&lt;String&gt; = XMLParser.parseChildText("kind")(xml: xml)
let name: Result&lt;String&gt; = XMLParser.parseChildTextRecursive(["nested_nonsense", "name"])
</code></pre>

<p>Lovely.</p>

<h3>Parsers for Other Types</h3>

<p>We&rsquo;ve seen that the definitions inside the <code>XMLParser</code> Helper don&rsquo;t provide methods for interpreting the <code>String</code> of a XML Text element as every possible Type as Numeric and Complex types within an XML document are represented in textual form. Our Model classes are concerned with Numeric types such as <code>Double</code> and <code>Int</code>, so the parsing of these types will need to be incorporated into the <code>decode</code> method.</p>

<p>Unlike JSON, there is no <a href="http://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example">explicit syntax for a Numeric value</a>, so the interpretation of these types isn&rsquo;t a requirement of an XML Parser. Instead of bloating the <code>XMLParser</code> class with every variation of interpreting Text as a other Types, the Parser functions for values in the Model can be composed with <code>XMLParser</code> functions and other functions that interpret <code>String</code>s as the other types.</p>

<p>Coercing a value from a String to a Numeric type may not always work. The String &lsquo;14123&rsquo; can be interpreted as an <code>Int</code> but the value <code>134djk23</code> cannot. Again, this falls into our notion of Model decoding failure. The <code>NSNumberFormatter</code> class is a Cocoa way of interpreting Strings as Numbers, we can write an extension for the  <code>Int</code> type to intepret a <code>String</code> as an <code>Int</code>, with <code>Optional.None</code> used to representing failure.</p>

<pre><code>public extension Int {
  public static func parseString(string: String) -&gt; Int? {
    let formatter = NSNumberFormatter()
    let number = formatter.numberFromString(string)
    return number?.integerValue
  }
}
</code></pre>

<p>As previously mentioned, Cocoa APIs in Swift expose failure as the <code>nil</code>/<code>.None</code> case of an Optional Type[^nserror-failure]. However, our Parser requires the additional information in a <code>Result</code> type. One approach is to extend Cocoa classes with additional methods that return a <code>Result</code> instead of an <code>Optional</code>, but this might not be the ideal solution<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>. Instead we can again think in terms of Function Composition to make a function that returns <code>Result&lt;Int&gt;</code> instead of <code>Int?</code></p>

<p>For example, a definition of <code>toiletCount</code> requires interpreting a <code>String</code> in the XML as an <code>Int</code> in the model. This function can be built from closures:</p>

<pre><code>let toiletCountParser: String -&gt; Result&lt;Int&gt; = { promoteDecodeError("Could not parse 'disabled_parking")(value: Int.parseString($0)) }
</code></pre>

<p>Or we can use the <a href=""><code>Compose</code> and <code>Bind</code> Operators again</a>:</p>

<pre><code>let toiletCountParser: String -&gt; Result&lt;Int&gt; = promoteDecodeError("Could not parse 'disabled_parking") • Int.parseString
let toiletCount =  XMLParser.parseChildText(["facilities", "toilet"])(xml: xml) &gt;&gt;- toiletCountParser
</code></pre>

<p>The <code>Animal</code> and <code>Zoo</code> Models both implement the <code>XMLDecoderType</code> protocol. In this case there are a number of <code>Animal</code> Models belonging to a <code>Zoo</code>, so the <code>decode</code> functions can be reused to extract out each of the <code>Animal</code> Models contained in a parent <code>Zoo</code>:</p>

<pre><code>let animals = XMLParser.parseChild("animals")(xml: xml) &gt;&gt;- XMLParser.parseChildren("animal") &gt;&gt;- resultMap(Animal.decode)
</code></pre>

<p>There is another function that takes the output of <code>XMLParser.parseChildren</code> as an input, of type <code>Result&lt;[X]&gt;</code>. The <code>resultMap</code> function is like a regular <code>map</code> on an <code>Array</code>, except with the return of a <code>Result.Error</code> if any of the applications of the <code>map</code> function fails:</p>

<pre><code>public func resultMap&lt;A, B&gt;(map: A -&gt; Result&lt;B&gt;)(array: [A]) -&gt; Result&lt;[B]&gt;
</code></pre>

<h3>Applicatives</h3>

<p>Now we have everything we need to extract values out of <code>XMLParsableType</code> and into <code>Result</code> containers for each of the values that need to be extracted. Now the <code>Result</code> values need to be chained in the following way:</p>

<blockquote><p><em>&ldquo;If all of the <code>Result</code>s corresponding to each of the Values are Successful, return our Model with the Values from the Result context applied to the Model Constructor function, otherwise just return the first Errored Result.&rdquo;</em></p></blockquote>

<p>Let&rsquo;s turn back to Curried Functions, this time to a Curried &lsquo;Constructor&rsquo;<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>:</p>

<pre><code>static func build(type: String)(name: String)(url: NSURL) -&gt; Animal {
  return self(type: type, name: name, url: url)
}
</code></pre>

<p>By adding a little more context to each of the applications of Higher-Order functions, we should be able to follow what is going on as the <code>Animal.build</code> function down to a <code>Result&lt;Animal&gt;</code>:</p>

<pre><code>// These are previously defined using Higher-Order functions and XMLParser
let type: Result&lt;String&gt; = ...
let name: Result&lt;String&gt; = ...
let url: Result&lt;NSURL&gt; = ...

// The Build Function is a Curried function that will yeild functions with every application until we have the Animal value.
let build: String -&gt; String -&gt; NSURL -&gt; Animal = self.build
// Each of these stage gets the Animal structure closer to being initialized
let first: Result&lt;String -&gt; NSURL -&gt; Animal&gt; = self.build &lt;^&gt; type
let second: Result&lt;NSURL -&gt; Animal&gt; = first &lt;*&gt; name
let third: Result&lt;Animal&gt; = second &lt;*&gt; url
</code></pre>

<p>This feels a lot like solving a Mathmatical equation by reducing the variables to balance each side of the equation. There are a few more Higer-Order functions that are being used here, doing the heavy lifting of pulling values and functions out of a <code>Result</code> context executing a function and then sticking the return value back in a <code>Result</code> again.</p>

<p>Firstly, the <a href="https://github.com/maxpow4h/swiftz/blob/master/swiftz_core/swiftz_core/Result.swift#L83"><code>fmap</code> operator</a>:</p>

<pre><code>public func &lt;^&gt;&lt;A, B&gt;(f: A -&gt; B, a: Result&lt;A&gt;) -&gt; Result&lt;B&gt;
</code></pre>

<p>It can be thought of in the following way:</p>

<blockquote><p><em>&ldquo;If the Result <em>a</em> is an Value apply the function <em>f</em> and place the result back in a Result, if the Result <em>a</em> is an Error, just return the Result immediately&rdquo;</em></p></blockquote>

<p>The property of this operator is that the applied function <code>f</code> doesn&rsquo;t have to ever have to be aware that the applied argument has been part of a <code>Result</code> context.</p>

<p>Secondly, we can take a look the <a href="https://github.com/maxpow4h/swiftz/blob/master/swiftz_core/swiftz_core/Result.swift#L94"><code>apply</code> operator</a>:</p>

<pre><code>public func &lt;*&gt;&lt;A, B&gt;(f: Result&lt;A -&gt; B&gt;, a: Result&lt;A&gt;) -&gt; Result&lt;B&gt;
</code></pre>

<p>It too can be described:</p>

<blockquote><p> <em>&ldquo;If the Result <em>f</em> is an Error just return it immediately, if the Result <em>a</em> is an Error just return it immediately. Otherwise pull the function out of <em>f</em> and the value out of <em>a</em>, apply <em>a</em> to <em>f</em> then place the returned value in a Result&rdquo;</em></p></blockquote>

<p>Again, these functions themseves no longer need to be aware that values are contained in a <code>Result</code> context.</p>

<p>Between <code>&lt;^&gt;</code>, <code>&lt;*&gt;</code> and <code>&gt;&gt;-</code> all the combinations of applying Values to Functions inside and outside of a <code>Result</code> are covered. These Operators allow us to use pull values and functions into-and-out-of <code>Result</code> contexts, using functions that don&rsquo;t have to be aware of the fact that the values and Functions may have come out of a <code>Result</code><sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>.</p>

<h3>Teach the Controversy</h3>

<p>There&rsquo;s a lot to take in, some of the benefits should be clear, others are a bit more subtle. I don&rsquo;t deny some of this doesn&rsquo;t have a steep learning curve, it may go against many years of experience with languages that don&rsquo;t have semantics for dealing with Functions as things that can be combined in these ways. All of these concepts and implementations are nothing new and are the products of high-shouldered giants. With the modernity of Swift we have the opportunity to incorporate more Functional Programming into Native iOS and Mac Developments. Given that there are certain programming techniques that can&rsquo;t be carried over from Objective-C, its worth considering incorporating some Functional Programming if it fits the task at hand.</p>

<p>There&rsquo;s a lot of concern that Operator Overloading is going to lead to a lot of Smart People doing some very silly things<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup> for the purpose of making dense, concise and far-too-clever code. The reality of these operators is that they are small in number and aren&rsquo;t specific to just <code>Optional</code> and <code>Result</code>. As Arithmetic Operators deal with Numeric values, Functional Operators operators deal with the transformation of Functions themselves. These concepts are taken from other languages, so they aren&rsquo;t at all specific to Swift.</p>

<p>There&rsquo;s also some new terminologies and another way of describing the interaction of components, this isn&rsquo;t less true of a <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage/VisualFormatLanguage.html">Domain Specific Language</a> that we can graft on top of Objective-C[^objc-dsls] or with a <a href="http://robots.thoughtbot.com/writing-a-domain-specific-language-in-ruby">more flexible language</a>. Sure, Objective-C has the benefit of a preprocessor to graft new features onto the language to and reduce the amount of boiler-plate required<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup>, but these can become pretty opaque over time.</p>

<p>However, unlike a Domain Specific Language, all of the code used is valid Swift, there is no transformation from a language in one domain, to a syntax that the compiler understands. The Compiler is fully aware of the Types of all of the transformed Functions leaving no room for ambiguity. The chances of a runtime error because of a <a href="http://stackoverflow.com/questions/8561558/objective-c-keyvaluecoding-how-to-avoid-an-exception-with-valueforkeypath">keypath not existing</a> or the type being <a href="http://stackoverflow.com/questions/2455161/unrecognized-selector-sent-to-instance">different to the one expected by the code</a> are greatly diminished.</p>

<p>I honestly believe its worth taking a jump at the conceptual hurdle, whether it is for writing code that is more robust and predictable or to satisfy a curiosity of learning something new.</p>

<p>Thanks for Reading! I suggest reading some other brilliant posts that do a better job than I of laying this all out! As a bonus, the next post will focus on how <code>XMLParsableType</code> can be implemented in a variety of ways.</p>

<hr />
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Swiftz has a Core library as well as a more full-featured Framework. There&rsquo;s a lot of interesting stuffin the Full library, but just getting started with the Core is a good place to start.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>I&rsquo;m lying, I&rsquo;ve changed the Generic Parameters from <code>VA</code> &amp; <code>VB</code> to <code>A</code> &amp; <code>B</code><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>They consume a Protocol, abstracting away how the XML Parser is implemented. As the Protocol has an associated type requirement it has to be fulfilled with Generics. Composed behaviours don&rsquo;t pollute the Implementation of the Protocol but still augment the behaviour.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>When starting out it can be really helpful to do this, it makes inspecting the types of each of the elements in the chain more visible. You can use Alt+Click on the value name to get XCode to print out the inferred type. Its also a good illustration of the power of type inference.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Swift makes strong guarantees about the existance of values, there&rsquo;s no need to check for the existance of values in arguments that are non-optional. In an Objective-C implementation this contract can be enforced with a litany of assertions. If the language and compiler can enforce these guarantees we&rsquo;ve got a huge productivity win on our hands.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>As the functions consume a Protocol with associated type requirements the Protocol type has to be defined as a Generic type. The functions are <a href="http://en.wikipedia.org/wiki/Pure_function">Pure</a> in that they do not consume or modify any Global State, only the arguments are used. The guarantee of the no side-effects cannot be enforced in Swift. In essence the class is a bunch of similar functions that are kind-of-namespaced as Class methods of a <code>final</code> class with no constructor.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>And it could be damaging to the codebase. Cocoa Classes could easily become polluted with <code>Result</code> variants of every possible method that could fail and this would continue over time as more classes are required to be parsed. More importantly it is not possible for a General <code>Result</code> returning type to have some of the crucial context surrounding a failure. We want our <code>NSError</code>s to contain the Element within the XML responsible for the failure, an Extension method would lose this context. <em>&lsquo;Failed to interpret &#8216;toilet&rsquo; as an Int&#8217;</em> is preferable to <em>&lsquo;Failed to interpret &#8216;123a&rsquo; as an Int&#8217;</em><a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>&lsquo;Factory Method&rsquo; is probably a better term for this since a &lsquo;Constructor&rsquo; is a term reserved to <code>init</code> methods in Swift. <a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p><code>Optional</code> and <code>Result</code> are examples of Functors and Monads. This <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">fantastic article</a> covers the operators in a visual way. There&rsquo;s more of these (Monads) than you might first think and its a <a href="http://www.haskell.org/haskellwiki/Monad#Interesting_monads">crucial part of many functional languages</a>.<a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
<li id="fn:10">
<p>This happens when any <a href="http://en.wikipedia.org/wiki/Operator_overloading#1980s"><em>&lsquo;new&rsquo;</em></a> language feature comes along. I know I abused blocks when they appeared in Objective-C.<a href="#fnref:10" rev="footnote">&#8617;</a></p></li>
<li id="fn:11">
<p>In Objective-C this can be handled with <a href="https://github.com/rentzsch/NSXReturnThrowError">Macros and Early Return</a>, but we can&rsquo;t rewrite/mangle the rules of the language in Swift as we don&rsquo;t have Macros.<a href="#fnref:11" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
